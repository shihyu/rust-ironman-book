<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>錯誤處理 - Rust Ironman 合併彙整</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Ironman 合併彙整</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h1>
<ul>
<li>系列：30 天深入淺出 Rust</li>
<li>來源系列：https://ithelp.ithome.com.tw/users/20111802/ironman/1742</li>
<li>原文連結：https://ithelp.ithome.com.tw/articles/10200793</li>
<li>章節：DAY 11</li>
<li>發佈時間：2018-10-11 21:42:37</li>
<li>作者：DanSnow</li>
<li>清單瀏覽數：3300</li>
<li>清單摘要：現在大多的程式語言都有例外 (exception) ，這讓程式碰到錯誤時可以立即的拋出例外，拋出的例外會中斷目前整個程式的流程，並開始往上找例外處理的程式，可是...</li>
</ul>
<h2 id="內文"><a class="header" href="#內文">內文</a></h2>
<p>現在大多的程式語言都有例外 (exception)
，這讓程式碰到錯誤時可以立即的拋出例外，拋出的例外會中斷目前整個程式的流程，並開始往上找例外處理的程式，可是
Rust 並沒有這種機制。</p>
<p>Rust 中主要是以回傳值 <code>Result</code>
來代表有無錯誤的，此外也有可以立即中止程式的 <code>panic!</code> 。</p>
<h2 id="panic"><a class="header" href="#panic"><code>panic!</code></a></h2>
<p>先介紹之前沒用過的 <code>panic!</code> ， <code>panic!</code>
會直接終止目前的執行緒，如果你呼叫了 <code>Result::unwrap</code> 或
<code>Option::unwrap</code> ，它們也會分別在值為 <code>Err</code> 或 <code>None</code>
時發生，這用在程式碰到了無法回復的錯誤。</p>
<blockquote>
<p><code>panic!</code> 也像 <code>println!</code> 是 macro
，所以那個驚嘆號是要加的，此外它裡面也可以放格式化字串，使用方法是一樣的。</p>
</blockquote>
<p>主執行緒遇到 <code>panic!</code> 時，程式會印出 <code>panic!</code>
內的訊息，與發生位置後結束程式，你也用以下方法執行程式，你會得到更詳細的輸出：</p>
<pre><code class="language-shell">$ RUST_BACKTRACE=1 cargo run
</code></pre>
<p>如果是子執行緒發生 panic 的話等到之後講到多執行緒時再來介紹。</p>
<blockquote>
<p>執行緒是電腦執行的單位，如果你的 CPU 有 4 核心，那你的電腦就能一次跑 4
個執行緒，所以現在很多程式為了加速會在一個程式裡產生多個執行緒，同時執行多個工作來加速，現在我們寫的程式都只有一個執行緒，也就是主執行緒而已。</p>
</blockquote>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>之前有介紹過 <code>Result</code> 是一個列舉，其由兩個 variant 組成，分別是 <code>Ok</code> 與
<code>Err</code> ，之前我們有在猜數字的遊戲中使用過
<a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse"><code>str::parse</code></a>
來把字串轉換成數字，它的回傳值的型態就是 <code>Result</code> ，但要怎麼知道是
<code>Result</code> 呢？除了看文件也有個簡單的辦法是像這樣：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let res: i32 = "123".parse::&lt;i32&gt;();
}</code></pre></pre>
<p>拿去編譯的話你就會看到像這樣的錯誤訊息：</p>
<pre><code class="language-plain">error[E0308]: mismatched types
 --&gt; src/main.rs:2:18
  |
2 |   let res: i32 = "123".parse::&lt;i32&gt;();
  |                  ^^^^^^^^^^^^^^^^^^^^ expected i32, found enum `std::result::Result`
  |
  = note: expected type `i32`
             found type `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>或是如果你有裝好 VSCode 的 Rust
的外掛的話應該也可以在滑鼠移上去後看到像這樣的提示：</p>
<p><img src="images/day-11-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86/img-001.png" alt="editor-hint" /></p>
<p>不過這邊的錯誤也只有可能是字串中有非數字的字元而已，另一個比較複雜的範例是開啟檔案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = match File::open("myfile") {
  Ok(f) =&gt; f,
  Err(err) =&gt; {
    // ...
  }
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>關於 <code>File</code> 的文件在
<a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code>std::fs::File</code></a></p>
</blockquote>
<p>這邊的 <code>err</code> 是
<a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html"><code>std::io::Error</code></a>
，這是在有讀寫，或是比較跟系統底層有關時， Rust
的標準函式庫常回傳的錯誤型態，同時它還有個與之搭配的列舉
<a href="https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html"><code>std::io::ErrorKind</code></a>，用來代表錯誤的類別，於是我們可以像這樣使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::ErrorKind;

let f = match File::open("myfile") {
  Ok(f) =&gt; f,
  // kind 是 std::io::Error 才有的方法，將會傳回代表錯誤類型的 ErrorKind
  Err(err) =&gt; match err.kind() {
    ErrorKind::NotFound =&gt; panic!("找不到檔案"),
    ErrorKind::PermissionDenied =&gt; panic!("權限不足"),
    err =&gt; panic!("開檔錯誤 {:?}", err),
  }
};
<span class="boring">}</span></code></pre></pre>
<p>像這樣子進行更複雜的處理，也可以在找不到時建立一個檔案也是行的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::ErrorKind;

let f = match File::open("myfile") {
  Ok(f) =&gt; f,
  // kind 是 std::io::Error 才有的方法，將會傳回代表錯誤類型的 ErrorKind
  Err(err) =&gt; match err.kind() {
    ErrorKind::NotFound =&gt; {
      match File::create("myfile") {
        // 檔案建立成功
        Ok(f) =&gt; f,
        Err(err) =&gt; panic!("無法建立檔案 {:?}", err),
      }
    }
    err =&gt; panic!("開檔錯誤 {:?}", err),
  }
};
<span class="boring">}</span></code></pre></pre>
<h2 id="-運算子"><a class="header" href="#-運算子"><code>?</code> 運算子</a></h2>
<p>不要懷疑，這個運算子就是 <code>?</code>
，如果有個函式在它呼叫其它函式時發生了錯誤的情況，它，它就把錯誤往上回傳：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Read};

fn read_and_append&lt;R: Read&gt;(reader: R) -&gt; io::Result&lt;String&gt; {
  let mut buf = String::new();
  match reader.read_to_string(&amp;mut buf) {
    // 成功的話什麼都不用做
    Ok(_) =&gt; {}
    // 失敗的話直接回傳錯誤
    Err(err) =&gt; return Err(err),
  }
  // 假設這邊還要做些處理後才回傳
  buf.push_str("END");
  // 回傳成功的結果
  Ok(buf)
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>Read</code> 是所有可讀取的東西會實作的一個 trait
，這包含檔案，或是標準輸入等等關於它的文件在
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code>std::io::Read</code></a></p>
</blockquote>
<p>其中的判斷錯誤，如果是錯誤就回傳的這段因為太常用到了，所以 Rust
就提供了個簡寫的方法，我們可以直接把上面的 <code>match</code> 那段改寫成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>reader.read_to_string(&amp;mut buf)?;
<span class="boring">}</span></code></pre></pre>
<p>如果它在成功時是會有回傳值的，比如 <code>File::open</code> 成功會回傳 <code>File</code>
，一個代表檔案的 struct ，那你也可以使用 <code>?</code> ：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open("filename")?;
<span class="boring">}</span></code></pre></pre>
<p><code>?</code> 只能在會回傳 <code>Result</code>
的函式中使用，不過因為它實在是太方便了，所以後來 Rust 的 <code>main</code>
函式也支援回傳 <code>Result</code> 了：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;

fn main() -&gt; Result&lt;(), io::Error&gt; {
  let f = File::open("filename")?;
  // 因為回傳值變 Result 了，所以這邊要回傳 Ok
  Ok(())
}</code></pre></pre>
<h2 id="該用-panic-還是回傳-result"><a class="header" href="#該用-panic-還是回傳-result">該用 <code>panic!</code> 還是回傳 <code>Result</code></a></h2>
<p>一般的規則就是，能被處理的就用 <code>Result</code> ，嚴重的錯誤才用 <code>panic!</code> 。</p>
<h2 id="自訂-error"><a class="header" href="#自訂-error">自訂 Error</a></h2>
<p>在
<a href="https://doc.rust-lang.org/stable/std/error/trait.Error.html"><code>std::error::Error</code></a>
中定義了一個代表 Error 的 struct 應該要支援的兩個方法 <code>description</code> 與
<code>cause</code> ，此外同時還要實作 <code>Debug</code> 與 <code>Display</code> ，不過實際上
<code>description</code> 與 <code>cause</code>
都有提供預設的實作，於是這些之中一定要實作的就只有 <code>Display</code>
了，此外也可以實作 <code>cause</code> 用來指明發生這個錯誤的原因：</p>
<pre><pre class="playground"><code class="language-rust">use std::io;
use std::fmt;
use std::error::Error;

// 建一個能包裝 io::Error 的 struct
#[derive(Debug)] // 實作 Debug
struct MyError(Option&lt;io::Error&gt;);

impl fmt::Display for MyError {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    // 寫出自訂的錯誤訊息
    f.write_str("這是自訂的錯誤: ")?;
    match self.0 {
      Some(ref err) =&gt; {
        // 如果有包裝的 io::Error 就把它的訊息印出來
        write!(f, "{}", err)
      }
      None =&gt; {
        write!(f, "沒有包裝的 io::Error")
      }
    }
  }
}

impl Error for MyError {
  // 覆寫原本的 cause ，在如果有原本的 io::Error 時傳回去
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {
    // 這邊很可惜沒辦法用 Option::as_ref
    match self.0 {
      Some(ref err) =&gt; Some(err),
      None =&gt; None,
    }
  }
}

// 從 io::Error 轉換成 MyError
impl From&lt;io::Error&gt; for MyError {
  fn from(err: io::Error) -&gt; Self {
    MyError(Some(err))
  }
}

fn main() {
  let err = MyError(None);
  println!("{}", err);
  let err = MyError(Some(io::Error::new(io::ErrorKind::Other, "Demo")));
  println!("{}", err);
}</code></pre></pre>
<blockquote>
<p><code>write!</code> 的用法也和 <code>println!</code>
很像，只是第一個參數必須是可以寫入的，也就是有實作
<a href="https://doc.rust-lang.org/stable/std/fmt/trait.Write.html"><code>std::io::Write</code></a>
的物件，所以也可以用在 <code>File</code>
上，而第二個開始才是原本的格式化字串，它不像 <code>println!</code>
一樣會自動加換行。</p>
</blockquote>
<p>這邊做了一個我們自己的 Error ，並還包裝了原本的 <code>io::Error</code> ，最後一個
<code>From</code> 的實作其實並不是必要的，只是實作了會很有用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Result&lt;(), MyError&gt; {
  Err(io::Error::new(io::ErrorKind::Other, "Demo"))?;
  unreachable!("這邊永遠不會執行到");
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>unreachable!</code> 同樣也是個 macro
它的功能在提示編譯器這種情況不該發生，否則編譯器會認為你的程式可能沒有回傳值，那如果真的執行到了呢？答案是會
panic</p>
</blockquote>
<p>這邊可以看到我們用 <code>?</code> 運算子在碰到 <code>Err(io::Error)</code>
時提早回傳了，只是我們的回傳值明明是寫 <code>MyError</code> 呀，事實上用 <code>?</code>
運算子回傳時會使用 <code>MyError::from</code> 去轉換回傳的錯誤，當我們有幫
<code>MyError</code> 定義 <code>From&lt;io::Error&gt;</code> 時就能被自動轉換。</p>
<p>當你使用多個第三方的套件時，可能大家都會定義自己的錯誤型態，這時你可以嘗試使用列舉來包裝不同的錯誤型態，同時定義
<code>From</code>
來做轉換，這樣你就能在程式裡使用一個統一的錯誤型態了，因為這件事情太常用了，所以有個叫
<a href="https://github.com/rust-lang-nursery/failure">failure</a>
的套件就把這件事用比較簡單的方式完成了，可惜因為再介紹下去篇幅會有點長，所以到後面實作專案時再來介紹吧。</p>
<blockquote>
<p>題外話，實際上 <code>Result</code> 中代表錯誤的型態並沒有必要實作 <code>Error</code>
，只是一般還是會用實作了 <code>Error</code> 的型態來代表錯誤。</p>
</blockquote>
<h2 id="自訂-panic-的訊息-進階"><a class="header" href="#自訂-panic-的訊息-進階">自訂 panic 的訊息 (進階)</a></h2>
<p>你可以在程式開始時註冊一個處理 panic 的函式：</p>
<pre><pre class="playground"><code class="language-rust">use std::panic;

fn handle_panic&lt;'a&gt;(_info: &amp;panic::PanicInfo&lt;'a&gt;) {
  println!("天啊，程式爆炸了");
}

fn main() {
  panic::set_hook(Box::new(handle_panic));
  panic!("Boom");
}</code></pre></pre>
<p>在這個函式裡你還可以拿到 panic 發生時的位置，與傳給 panic 的訊息：</p>
<pre><pre class="playground"><code class="language-rust">use std::panic;

fn handle_panic&lt;'a&gt;(info: &amp;panic::PanicInfo&lt;'a&gt;) {
  if let Some(loc) = info.location() {
    println!("在 {} 的第 {} 行", loc.file(), loc.line())
  } else {
    println!("不知道在哪邊");
  }

  // 這邊的 payload 的回傳值是 Any
  // downcast_ref 是嘗試把 Any 這個型態轉換成指定的型態
  // 如果轉換不成功就會回傳 None
  if let Some(msg) = info.payload().downcast_ref::&lt;&amp;str&gt;() {
    println!("訊息： {}", msg);
  } else {
     println!("沒有訊息或訊息不是 str");
  }
  println!("總之爆炸了");
}

fn main() {
  panic::set_hook(Box::new(handle_panic));
  panic!("Boom");
}</code></pre></pre>
<blockquote>
<p>Any 是個特殊的 trait
，它幫大部份型態都實作過了一遍，透過編譯器的協助，幫每個型態都分配了一個代碼，要使用時你要使用
downcast_ref 或 downcast_mut
，只要你要求轉換的型態與原本的型態符合就會轉換成功，詳細可以參考文件的
<a href="https://doc.rust-lang.org/stable/std/any/trait.Any.html"><code>std::any::Any</code></a></p>
</blockquote>
<p>也有人使用 <code>set_hook</code> 的功能實作了一個會在 panic
時寫出紀錄檔的功能，有興趣可以看看這個專案
<a href="https://github.com/rust-clique/human-panic">human-panic</a> 。</p>
<blockquote>
<p>最開頭的地方說 Rust 沒有例外處理的機制也不是完全正確的， Rust
現在有能力捕捉 panic 了，只是這並沒有保證一定能捕捉到 panic
還要看編譯時的設定…等等的條件，有興趣可以看看
<a href="https://doc.rust-lang.org/stable/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind</code></a>
，這功能主要的目的是當你使用其它語言呼叫 Rust 的程式時，讓你可以避免
Rust 的 panic 影響到其它的程式語言，平常如果要回傳錯誤的話還是請用
<code>Result</code> ，不要依賴這個。</p>
</blockquote>
<p>下一篇要來介紹如何在 Rust 中寫測試。</p>
<h2 id="ascii-詳細示意圖"><a class="header" href="#ascii-詳細示意圖">ASCII 詳細示意圖</a></h2>
<pre><code class="language-text">═══════════════════════════════════════════════════════════════
                      錯誤處理
═══════════════════════════════════════════════════════════════

【Rust 錯誤處理策略】

  ┌─────────────────────────────────────────┐
  │              程式執行中發生錯誤           │
  └───────────────────┬─────────────────────┘
                      │
          ┌───────────┴───────────┐
          │                       │
          v                       v
  ┌───────────────┐       ┌───────────────┐
  │  可恢復錯誤    │       │  不可恢復錯誤  │
  │  Result&lt;T,E&gt;  │       │  panic!       │
  └───────┬───────┘       └───────┬───────┘
          │                       │
    ┌─────┴─────┐           ┌─────┴─────┐
    │           │           │           │
    v           v           v           v
  match      ? 運算子    印出訊息    stack unwinding
  手動處理   自動傳播    結束執行緒   逐層釋放資源

─────────────────────────────────────────────────────────────
【? 運算子 — 錯誤自動傳播】

  沒有 ? 的寫法：                 使用 ? 的寫法：
  ┌────────────────────────┐    ┌────────────────────────┐
  │ let buf = match reader │    │ reader.read_to_string  │
  │   .read_to_string(buf) │    │   (&amp;mut buf)?;         │
  │ {                      │    │                        │
  │   Ok(_) =&gt; {},         │    │ // 成功 → 繼續         │
  │   err =&gt; return err,   │    │ // 失敗 → 自動 return  │
  │ };                     │    │ //        Err(e)       │
  └────────────────────────┘    └────────────────────────┘

  ? 運算子的行為流程：
  ┌──────────┐     ┌────────────────────────────────┐
  │ expr?    │────&gt;│ 是 Ok(val)?                     │
  └──────────┘     │   → 展開，得到 val，繼續執行     │
                   │                                  │
                   │ 是 Err(e)?                       │
                   │   → 呼叫 From::from(e) 轉型      │
                   │   → return Err(converted_e)      │
                   └────────────────────────────────┘

─────────────────────────────────────────────────────────────
【自訂 Error 的架構】

  ┌──────────────────────────────────────────┐
  │  #[derive(Debug)]                        │
  │  struct MyError(Option&lt;io::Error&gt;);      │
  └──────────────┬───────────────────────────┘
                 │
     ┌───────────┼───────────┬───────────────┐
     │           │           │               │
     v           v           v               v
  Display    Error trait   From&lt;io::Error&gt;  Debug
  (必須)     (cause 等)   (讓 ? 自動轉型)  (derive)

  使用 From 的效果：
  fn foo() -&gt; Result&lt;(), MyError&gt; {
      let f = File::open("x")?;
      //                     ^ io::Error
      //                       → From::from(io::Error)
      //                       → MyError(Some(io::Error))
      //                       自動轉型！
      Ok(())
  }

─────────────────────────────────────────────────────────────
【ErrorKind 分類處理】

  File::open("myfile")
         │
         v
  ┌──── Ok(f) ────&gt; 使用檔案 f
  │
  └──── Err(e) ──&gt; e.kind()
                       │
              ┌────────┼────────────┐
              v        v            v
         NotFound  PermissionDenied  其他
              │        │            │
              v        v            v
         建立檔案    panic!      panic!
         或 panic    "權限不足"   "開檔錯誤"
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../series-1/day-10-module.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../series-1/day-12-單元測試.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../series-1/day-10-module.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../series-1/day-12-單元測試.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
