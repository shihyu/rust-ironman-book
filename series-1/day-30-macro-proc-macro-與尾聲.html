<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>macro 、 proc macro 與尾聲 - Rust Ironman 合併彙整</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Ironman 合併彙整</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="macro--proc-macro-與尾聲"><a class="header" href="#macro--proc-macro-與尾聲">macro 、 proc macro 與尾聲</a></h1>
<ul>
<li>系列：30 天深入淺出 Rust</li>
<li>來源系列：https://ithelp.ithome.com.tw/users/20111802/ironman/1742</li>
<li>原文連結：https://ithelp.ithome.com.tw/articles/10206778</li>
<li>章節：DAY 30</li>
<li>發佈時間：2018-10-30 23:08:54</li>
<li>作者：DanSnow</li>
<li>清單瀏覽數：2600</li>
<li>清單摘要：這是最後一篇了，這篇我會補一些之前沒講到的東西，內容會比較雜一點。 目錄： macro Procedural Macro (進階) 權限修飾 Rust 心得...</li>
</ul>
<h2 id="內文"><a class="header" href="#內文">內文</a></h2>
<p>這是最後一篇了，這篇我會補一些之前沒講到的東西，內容會比較雜一點。</p>
<p>目錄：</p>
<ul>
<li>macro</li>
<li>Procedural Macro (進階)</li>
<li>權限修飾</li>
<li>Rust 心得</li>
<li>鐵人賽後記</li>
</ul>
<h2 id="macro"><a class="header" href="#macro">macro</a></h2>
<p>Rust 的 macro
同樣也是基於模式比對的，如果你發現了類似結構的程式碼重覆了，說不定你可以把它寫成
macro 來減少你的程式碼，比如像昨天使用的 <code>clone!</code> ：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! clone {
  ($($name:ident),*) =&gt; {
    $(
      let $name = $name.clone();
    )*
  };
}
<span class="boring">}</span></code></pre></pre>
<p>定義一個 macro 你需要使用 <code>macro_rules!</code> 接著你想要的 macro
名稱，名稱的規則跟變數一樣，這邊使用的是 <code>clone</code> ，之後你的 macro 就會變
<code>clone!</code> 。</p>
<p>接下來則是分成兩個部份，模式定義的部份與產生的程式碼，兩邊都必須使用成對的括號包住，中間使用
<code>=&gt;</code> 分隔，最後則要用 <code>;</code> 結束
(只有一個定義時可以不用)，左邊的模式幾乎可以隨便定義，只是還是有些規則在，主要是不能造成編譯器出現歧義的情況，也就是同一段程式碼能有兩種不同的解釋，像
macro 中能用 <code>expr</code> 去比對運算式，但是運算式後就規定不能出現運算子 (+
、 - 、 * 、 / 等等) 。</p>
<p>上面的 <code>$name:ident</code> 代表的是比對一個識別字 (變數或 struct
的名字等等)，前面的 <code>$name</code> 是 macro 中使用的變數，在展開後 <code>$name</code>
會被代換成傳入的東西，後面的 <code>ident</code>
則代表是要比對識別字，可以比對的東西有這些：</p>
<ul>
<li>item： 各式各樣的完整定義與宣告都是 item ，比如一個 struct 的定義</li>
<li>block： 一個程式碼區塊，就是由一對 <code>{</code> 和 <code>}</code> 包起來的區塊</li>
<li>stmt： 一個程式敘述，就是一行有加 <code>;</code> 的程式碼</li>
<li>pat： 一個模式比對用的模式，如 <code>Point { x, y }</code></li>
<li>expr： 一個運算式，基本上就是一行沒加括號有回傳值的程式，這個挺常用的</li>
<li>ty： 一個型態</li>
<li>ident： 一個識別字，或一個關鍵字也行，這個也是常用的</li>
<li>path： 比如像 <code>std::vec::Vec</code> 這樣的</li>
<li>meta： <code>#[]</code> 中的內容</li>
<li>lifetime： 就是 lifetime</li>
<li>vis： 像 <code>pub</code> 這樣的設定可見性的東西</li>
<li>tt： 可以 match 任何東西，通常是用來收集還沒比對到的部份用的</li>
</ul>
<p>比如我可以定義：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($left:ident =&gt;____&lt;= $right:expr) =&gt; {
    println!("{} =&gt;____&lt;= {}", stringify!($left), $right);
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123);
// 會印出： "bar =&gt;____&lt;= 123"
<span class="boring">}</span></code></pre></pre>
<p>其中 <code>stringify!</code> 是個內建的 macro
，可以把傳進去的東西原封不動的轉成字串，沒錯， macro 可以遞迴展開。</p>
<p>如果要重覆的比對的話就要用 <code>$()*</code> 或 <code>$()+</code> 了， <code>+</code> 是比對 1 個以上，而
<code>*</code> 則是可以為 0 個，如果我們把上面的範例加上 <code>$()*</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($($left:ident =&gt;____&lt;= $right:expr)*) =&gt; {
    $(
      println!("{} =&gt;____&lt;= {}", stringify!($left), $right);
    )*
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123 baz =&gt;____&lt;= 456);
// 會印出：
// bar =&gt;____&lt;= 123
// baz =&gt;____&lt;= 456
<span class="boring">}</span></code></pre></pre>
<p>用哪種重覆的方式就要用哪種去展開，在結尾的 <code>*</code> 或 <code>+</code>
前可以放上分隔用的符號，通常用會 <code>,</code> 或 <code>;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($($left:ident =&gt;____&lt;= $right:expr),*) =&gt; {
    $(
      println!("{} =&gt;____&lt;= {}", stringify!($left), $right);
    )*
  };
}

// 使用：

foo!(bar =&gt;____&lt;= 123, baz =&gt;____&lt;= 456);
// 會印出：
// bar =&gt;____&lt;= 123
// baz =&gt;____&lt;= 456
<span class="boring">}</span></code></pre></pre>
<p>Rust 的 macro 很強大，又能遞迴展開，使用的好能做出各式各樣的效果，比如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  // 遞迴的終止條件
  ($left:ident -&gt; $right:expr) =&gt; {
    println!("{} -&gt; {}", stringify!($left), $right);
  };

  // 遞迴的終止條件
  ($left:ident =&gt; $right:expr) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
  };

  ($left:ident -&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!("{} -&gt; {}", stringify!($left), $right);
    foo!($($rest)+);
  };

  ($left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
    foo!($($rest)+);
  };
}
<span class="boring">}</span></code></pre></pre>
<p>這樣就能支援兩種不同的分隔。</p>
<p>也有人在 macro 裡做出狀態機：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
  ($left:ident =&gt; $right:expr) =&gt; {
    foo!(@end $left =&gt; $right);
  };

  ($left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
    foo!(@second $($rest)+);
  };

  (@second $left:ident =&gt; $right:expr, $($rest:tt)+) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
    foo!(@end $($rest)+);
  };
  
  (@end $left:ident =&gt; $right:expr) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
  };

  (@end $left:ident =&gt; $right:expr, $($rest:tt)*) =&gt; {
    println!("{} =&gt; {}", stringify!($left), $right);
  };
}
<span class="boring">}</span></code></pre></pre>
<p>這會讓只能比對到 1 組或 3 組以上，而且超過第 3 組後都會被忽略，至於使用
<code>@</code> 只是個慣例，加上基本上程式裡不會出現。</p>
<p>另外還可以搭配 trait 來實作一些針對型態的特化等等的。</p>
<h2 id="procedural-macro-進階"><a class="header" href="#procedural-macro-進階">Procedural Macro (進階)</a></h2>
<p>這個功能就是像 <code>derive</code> 所使用的 trait ，或是可以自訂屬性 (像 <code>#[foo]</code>)
，社群有提供兩個很好用的 crate 可以幫忙實作，分別是
<a href="https://github.com/dtolnay/syn"><code>syn</code></a> 與
<a href="https://github.com/dtolnay/quote"><code>quote</code></a>。</p>
<p>這個專案在：
<a href="https://github.com/DanSnow/rust-intro/tree/master/proc-macro-demo">https://github.com/DanSnow/rust-intro/tree/master/proc-macro-demo</a></p>
<p>假設我們有個 trait 是定義一個函式回傳 struct 的名字：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Name {
  fn name() -&gt; &amp;'static str;
}
<span class="boring">}</span></code></pre></pre>
<p>然後我們把它變成可以 derive 的，於是我們必須建一個額外的函式庫專案，並在
<code>Cargo.toml</code> 中加上：</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>這樣編譯器才會知道這個 crate 是 proc macro 然後實作的程式碼如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate quote;
extern crate proc_macro;
extern crate proc_macro2;
extern crate syn;

use self::proc_macro::TokenStream;

// 定義一個 derive 名稱為 Name
#[proc_macro_derive(Name)]
// 這個函式的輸入輸出是規定的
pub fn name_derive(input: TokenStream) -&gt; TokenStream {
    let ast = syn::parse(input).unwrap();
    impl_name(&amp;ast).into()
}

fn impl_name(ast: &amp;syn::DeriveInput) -&gt; proc_macro2::TokenStream {
  // 取得 struct 的名稱
  let name = &amp;ast.ident;
  // 轉成字串，這樣才會在 quote 裡是 "&lt;名稱&gt;" 的型式
  let name_str = name.to_string();
  quote! {
    impl ::name::Name for #name {
      fn name() -&gt; &amp;'static str {
        #name_str
      }
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>使用像這樣：</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate name_derive;
extern crate name;

use name::Name;

#[derive(Name)]
struct Foo;

fn main() {
  println!("{}", Foo::name());
}</code></pre></pre>
<h2 id="權限修飾"><a class="header" href="#權限修飾">權限修飾</a></h2>
<p>之前提過用 <code>pub</code> 可以公開模組中的東西，事實上並不單只有這樣的用法：</p>
<ul>
<li><code>pub(crate)</code>： 讓這個東西能在這個 crate 中使用，但離開這個 crate
就不能</li>
<li><code>pub(in &lt;模組路徑&gt;)</code>： 只再開放給指定的模組，路徑也可以用 <code>self</code> 與
<code>super</code></li>
</ul>
<p>此外也可以把 <code>pub(in super)</code> 寫成 <code>pub(super)</code> ， <code>self</code>
也同樣，不過其實寫 <code>pub(self)</code>
就相當於是預設的，還有路徑只能是上層的路徑，下層的原本就都可以存取的。</p>
<h2 id="使用-rust-的心得"><a class="header" href="#使用-rust-的心得">使用 Rust 的心得</a></h2>
<p>當初知道 Rust
這個語言是因為火狐說要用這個語言重寫他們的引擎，那時就去查了一下，記得那個時候的第一印像是：「這什麼鬼，
struct 跟 impl
的定義是分開的？！」，不過後來嘗試後慢慢發現，這個語言雖然是個系統程式語言，但寫起來卻很方便，我在那之前主要使用的是
C++ ，接觸 Rust 後我最喜歡的是它的型態推導 (這在 C++ 裡可以用
auto)，跟它的模式比對 (這遠遠超過了 C++ 的 switch 了)，還有一些 FP
的特性，這是在 C++ 中比較缺乏，最重要的是 Rust 有強大的社群支援，還有
cargo 這個套件管理工具， C++
若想用一些第三方的東西真的會比較麻煩，而且在 Rust 中大量的使用了 RAII
，我可以不用擔心忘記釋放任何東西
(反倒要擔心東西不小心被釋放了，但「基本上」也不會發生) ，雖然剛開始被
lifetime 搞的很頭痛，但習慣後效率真的很高。</p>
<h2 id="鐵人賽後記"><a class="header" href="#鐵人賽後記">鐵人賽後記</a></h2>
<p>之前就一直想參加鐵人賽了，但是要寫什麼好呢？一直拿不定主意，介紹前端的
React 與 Vue
已經一堆了，競爭感覺很激烈，雖然我對於自己對這兩個東西的熟悉程度有自信，包含對它們底層的實作多多少少都有了解，我不只對新的東西感興趣，還對它們背後怎麼實現的感興趣，所以我覺得開源程式真是個好東西，多虧了開源，我去翻了
Vue 的 observer 的實作，去翻了 React 怎麼處理 event ，去翻了 ptrace 怎麼
trace system call
之類的，稍微扯遠了，但我對寫好文章沒什麼自信，我沒什麼寫文章的習慣的，那就挑個冷門點的題目吧，
Rust
這個語言也急速的在發展，或許以後會有不少人來用它寫些需要速度，或是偏底層的程式吧。</p>
<p>第一篇文章出來後，如果有編輯紀錄你應該會看到我反覆修了好幾次，那時貼出第一篇後拿給我朋友看，朋友：「我還以為你會先排版再貼上去」，於是我反覆修正了排版與用詞，雖然我從一開始就知道我的文章不適合初學者當教材了，我自己是覺得我的我文章像
Rust By Examples
，之前有位教授這樣說：「學生總是很困惑，老師在講什麼怎麼都聽不懂。老師也很困惑，學生到底為什麼不懂。」，一旦學會了什麼東西就會覺得很簡單，要再來教人就不容易了，雖然我也挺喜歡教人的，但有時我不知道自己的教法是不是正確的。</p>
<p>鐵人賽真的給了我個不錯的機會，有理由讓自己去寫文章，而且到後面還每天寫個專案(X
，其實除了網頁後端與資料庫那兩篇的專案都有事先準備外，其它的專案都是當天或前一天開始趕工做出來的，至於文章除了前幾篇外也都是當天新鮮的，所以那天如果到
10
點以後才發文大概是我那之前在除錯，這週花在鐵人賽的文章與相關的專案上的時數接近完整的
1 天啊，這次鐵人賽也讓我接觸到了兩樣之前沒碰過的，一個是 WebAssembly
，另一個是用 Rust 寫 GTK 程式 (之前只有用 C 寫過)。</p>
<p>最後一篇好像大多數人都會直接寫心得了，不過我還是有附上一點教學，因為理論上我的心得通常不會寫太多字，不過這個後記居然有將近
800 字其實我也是有點驚訝，要是我以前寫讀書心得也能寫的這麼順就好了。</p>
<p>總之謝謝正在看文章的你，以及之前提供我建議的讀者，拿 GTK
做井字棋可說完全是因為那則留言而產生的。</p>
<p>對了，原本我還想在這篇示範怎麼發佈個 crate ，然後把之前寫的那個
hastebin-client 發上去的，不過我還是先把程式碼整理一下吧。</p>
<h2 id="ascii-詳細示意圖"><a class="header" href="#ascii-詳細示意圖">ASCII 詳細示意圖</a></h2>
<pre><code class="language-text">Macro 與 Proc-macro 編譯階段

source tokens
   |
   +--&gt; declarative macro_rules!
   |        |
   |        v
   |    token expansion
   |
   +--&gt; procedural macro crate
            |
            v
       AST transform
            |
            v
expanded Rust code -&gt; normal compile pipeline
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../series-1/day-29-用-rust-gtk-做個井字棋.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../series-1/extra-01-番外-1-設計模式.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../series-1/day-29-用-rust-gtk-做個井字棋.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../series-1/extra-01-番外-1-設計模式.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
