<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函數式程式設計 - Rust Ironman 合併彙整</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Ironman 合併彙整</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="函數式程式設計"><a class="header" href="#函數式程式設計">函數式程式設計</a></h1>
<ul>
<li>系列：30 天深入淺出 Rust</li>
<li>來源系列：https://ithelp.ithome.com.tw/users/20111802/ironman/1742</li>
<li>原文連結：https://ithelp.ithome.com.tw/articles/10201241</li>
<li>章節：DAY 13</li>
<li>發佈時間：2018-10-13 21:18:18</li>
<li>作者：DanSnow</li>
<li>清單瀏覽數：2709</li>
<li>清單摘要：函數式程式設計的概念是來於數學上的函數，也就是一個輸入對應一個結果，不會受到其它東西的影響，所以程式講究沒有狀態，沒有副作用 (side effect) ，而在...</li>
</ul>
<h2 id="內文"><a class="header" href="#內文">內文</a></h2>
<p>函數式程式設計的概念是來於數學上的函數，也就是一個輸入對應一個結果，不會受到其它東西的影響，所以程式講究沒有狀態，沒有副作用
(side effect) ，而在 Rust
中也融入了很多函數式程式的概念與設計，比如預設不能修改的變數，以及能直接當成參數傳遞的函式等等。</p>
<blockquote>
<p>所謂的副作用是對函式外部的環境或狀態造成改變，所以像 OOP 那樣的修改
struct 甚至是對螢幕輸出都被視為副作用。</p>
</blockquote>
<h2 id="vec"><a class="header" href="#vec">Vec</a></h2>
<p>這邊先介紹一個 Rust 中的一個集合型態， <code>Vec</code> 又稱為 vector
(中文直翻為向量，但實際用途不同，所以這邊採用原文) ， <code>Vec</code>
可以想成一個可以動態成長的陣列，它必須儲存同樣類型的資料，如果你有個不確定大小的連續資料，比起使用陣列來存，用
<code>Vec</code> 來存就會方便很多。</p>
<p>定義一個空的 <code>Vec</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 因為我們接下來並沒有使用到，所以 Rust 這邊沒辦法自動推導裡面儲存的型態
// 所以只能用 Vec::&lt;i32&gt;::new 這樣的方式指定型態
let v = Vec::&lt;i32&gt;::new();

// 或是指定型態在變數後面
let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>直接定義一個有值的 <code>Vec</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// 這會定義一個有 10 個 0 的 Vec
let v = vec![0; 10];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>vec!</code> 也是 macro ， 這邊使用的括號是 <code>[]</code> ，事實上 Rust 中並沒有規定
macro 最外層用來包住參數的括號要使用哪一種，所以 <code>()</code> 、 <code>[]</code> 或 <code>{}</code>
都是可以用的，只要是成對的就行，這邊使用 <code>[]</code>
只是慣例，其它的單行就使用 <code>()</code> ，多行的則使用 <code>{}</code> 。</p>
</blockquote>
<p>在 <code>Vec</code> 的尾端增加元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(1);
v.push(2);
v.push(3);

println!("{:?}", v);
<span class="boring">}</span></code></pre></pre>
<p>這個結果會和上面的第一個一樣。</p>
<p>取值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

// 這邊跟陣列一樣從 0 開始，若取超過範圍會 panic
let n = v[1];

// 這邊回傳的是 Option&lt;&amp;i32&gt; ，若超過範圍只會回傳 None
let n = v.get(1);
<span class="boring">}</span></code></pre></pre>
<p>基本的使用大概是這樣，接下來我們要用到不少 <code>Vec</code> 。</p>
<h2 id="迭代-iterate"><a class="header" href="#迭代-iterate">迭代 (Iterate)</a></h2>
<p>還記得我們的 for 迴圈嗎？如果今天我們把陣列的每個元素都乘 2
並把結果存回一個 <code>Vec</code> 該怎麼寫呢？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let mut vec = Vec::new();

// 這邊的 i 型態是 &amp;i32
for i in array.iter() {
  vec.push(i * 2);
}

println!("{:?}", vec);
<span class="boring">}</span></code></pre></pre>
<p>上面的 <code>.iter</code> 會回傳一個迭代器 (iterator) ，讓你可以用 for
迴圈跑過陣列的每個元素，但迭代器所能做到的不只是這樣，以函數式的做法的話會像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
// Vec&lt;_&gt; 可以這樣寫是因為中間的型態可以讓編譯器自動推導
let vec = array.iter().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;();
// 如果你真的不喜歡 ::&lt;Vec&lt;_&gt; 的語法也可以改用型態標註
// let vec: Vec&lt;_&gt; = array.iter().map(|x| x * 2).collect();
println!("{:?}", vec);
<span class="boring">}</span></code></pre></pre>
<p><code>map</code> 做的事是把每個元素都用其中的函式做轉換，再產生一個新的迭代器。</p>
<p><code>collect</code>
則是把迭代器的值再搜集變成某個集合型態，注意的是這邊沒辦法使用陣列，因為它的大小必須在編譯時就決定，而
<code>collect</code> 只能使用能在執行時新增值的型態。</p>
<p>其中的 <code>|x| x * 2</code> 是接下來要介紹的閉包 (Closure)
的語法，它做的事情就是產生一個沒有名字的函式，也稱為匿名函式，將傳進來的參數乘
2 ，等下會詳細介紹語法與怎麼使用。</p>
<p>你也可以寫一個函式來做這件事：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這邊就像一般函式一樣要放型態了
fn time2(x: &amp;i32) -&gt; i32 { x * 2 }

let array = [1, 2, 3];
let vec = array.iter().map(time2).collect::&lt;Vec&lt;_&gt;&gt;();
println!("{:?}", vec);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Rust 中在函式裡定義函式並不會出錯喔</p>
</blockquote>
<p>如果要計算總合你會怎麼寫呢？請你試著用 for 迴圈寫一個看看吧。</p>
<p>寫好了嗎？我們可以用迭代器的 <code>sum</code> 來做加總：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
println!("{}", array.iter().sum::&lt;i32&gt;());
<span class="boring">}</span></code></pre></pre>
<p>如果要找出 1 到 10 之間的偶數，使用迭代器該怎麼做呢？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("{:?}", (1..=10).filter(|x| x % 2 == 0).collect::&lt;Vec&lt;_&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>range 本身就是迭代器了，所以直接呼叫方法就行了，這邊使用了 <code>filter</code>
來過濾出符合條件的元素。</p>
<p>Rust
的迭代器是延遲求值的，也就是只會使用到實際使用到的部份，所以如果使用一個有無限長度的迭代器，但只要只使用到有限的部份就不會出錯，讓我們來做高斯的經典題目吧：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("{}", (1..).take(100).sum::&lt;i32&gt;());
<span class="boring">}</span></code></pre></pre>
<p><code>1..</code> 會建一個從 1 開始一直到無限的範圍，但我們之後使用了 <code>take</code>
這使得它只會取前 100 個數字，最後再加總，你應該會看到它印出了 5050 。</p>
<blockquote>
<p>如果你把 <code>take</code>
拿掉，它也不會是無窮迴圈就是了，因為電腦整數的大小是有限的， Rust
會避免發生整數溢位，也就是當超過整數上限時，發生了數字變負數的一種情況。</p>
</blockquote>
<p>這邊介紹了一些迭代器的方法， Rust
中的迭代器其實挺快的，建議去看一下迭代器的文件，了解一下有哪些方法可以用。</p>
<h2 id="迭代器-iterator"><a class="header" href="#迭代器-iterator">迭代器 (Iterator)</a></h2>
<p>所以迭代器到底是什麼，我們實際來操作一次看看：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
// iter 中必須要記錄目前跑到哪個值，所以必須是 mut
let mut iter = array.iter();

println!("{:?}", iter.next()); // =&gt; Some(&amp;1)
println!("{:?}", iter.next()); // =&gt; Some(&amp;2)
println!("{:?}", iter.next()); // =&gt; Some(&amp;3)
// 已經沒有值了
println!("{:?}", iter.next()); // =&gt; None
// 沒有值後再繼續呼叫並不會錯誤，而是一直回傳 None
println!("{:?}", iter.next()); // =&gt; None
<span class="boring">}</span></code></pre></pre>
<p>上面的 <code>=&gt;</code> 後的結果是印出來的結果，簡單來說迭代器就是每次呼叫 <code>next</code>
就會回傳一個 <code>Option</code> 並包含下一個值。</p>
<p>我們自己來做一個迭代器，讓它從 1
開始產生到指定的數字就停止，如果要做一個迭代器就必須要實作 <code>Iterator</code>
這個 trait ：</p>
<blockquote>
<p><code>Iterator</code> 的文件在
<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a>
，在這邊還可以看到它提供了哪些方法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::iter::Iterator;

#[derive(Debug, Clone, Copy, Default)]
struct UpToIterator {
  // 這邊都採用無號整數，因為要是有負數很麻煩
  current: u32,
  upper_bound: u32,
}

impl UpToIterator {
  pub fn to(upper_bound: u32) -&gt; Self {
    UpToIterator { upper_bound, ..Default::default() }
  }
}

impl Iterator for UpToIterator {
  // 產生的值的型態
  type Item = u32;

  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    if self.current &lt; self.upper_bound {
      self.current += 1;
      Some(self.current)
    } else {
      None
    }
  }
}

fn main() {
  let mut iter = UpToIterator::to(10);
  for n in UpToIterator::to(10) {
    // 你應該會看到從 1 印到 10 的輸出
    println!("{}", n);
  }
}</code></pre></pre>
<h2 id="重新認識-for-迴圈-進階"><a class="header" href="#重新認識-for-迴圈-進階">重新認識 for 迴圈 (進階)</a></h2>
<p>其實 for 在 Rust 裡只是語法糖：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
for i in array.iter() {
  println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<p>這會被編譯器展開成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
{
  // 這是一個編譯器產生的暫時的變數
  let mut _iter = array.iter().into_iter();
  while let Some(i) = _iter.next() {
    println!("{}", i);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>這邊可以看到我們使用了 <code>while let</code> 的語法，這跟 <code>if let</code>
很像，只是變成是如果還是 <code>Some</code> 的話就繼續執行。</p>
<p><code>into_iter</code> 則是來自於
<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a>
這個 trait ， for 迴圈必須保證它後面的東西是個迭代器，所以會呼叫
<code>into_iter</code> 確保它被轉換成迭代器，相對而言，只要你的型態有實作
<code>IntoIterator</code> 就能被 for 迴圈所使用，要注意的是它會使用掉呼叫它的東西
(也就是它是使用 <code>self</code> 轉移了所有權) ，以下範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
// 這邊的 n 的型態是 i32
for n in v {
  println!("{}", n);
}
// 這邊沒辦法再使用 v
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Rust 中的慣例是若方法的開頭為 <code>into_</code> 則代表它會消耗掉使用它的東西。</p>
</blockquote>
<h2 id="閉包-closure"><a class="header" href="#閉包-closure">閉包 (Closure)</a></h2>
<p>以上面的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|x| x * 2
<span class="boring">}</span></code></pre></pre>
<p>宣告傳進來的參數 <code>|x|</code> ，在兩個 <code>|</code>
中放上參數的名字就好了，大多的情況下都不用加上型態宣告，這邊會自動推導，接下來放函式的主體，如果只有一行的話你可以不用加上大括號，或是加上大括號放進多行的程式。</p>
<p>閉包可以存到一個變數去：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x| x * 2;
println!("{}", f(10));
<span class="boring">}</span></code></pre></pre>
<p>若你需要宣告型態的話：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x: i32| -&gt; i32 { x * 2 };
<span class="boring">}</span></code></pre></pre>
<p>只是這邊就一定要加上大括號了。</p>
<p>閉包可以取得區域變數：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 3;
let f = |x| x * n;
println!("{}", f(10));
<span class="boring">}</span></code></pre></pre>
<p>預設閉包為用唯讀 borrow 來取得外部的變數，如果加上 <code>mut</code>
宣告，則閉包會用可寫的 borrow 取得外部的變數：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut n = 0;
let mut counter = || {
  n += 1;
  n
};
println!("{}", counter());
println!("{}", counter());
println!("{}", counter());
<span class="boring">}</span></code></pre></pre>
<p>若要讓閉包取得外部的變數的所有權，可以加上 <code>move</code> 關鍵字：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let is_equal_v = move |a| v == a ;
println!("{}", is_equal_v(vec![1, 2, 3]));
println!("{}", is_equal_v(vec![4, 5, 6]));
// 這邊無法使用 v
<span class="boring">}</span></code></pre></pre>
<p>至於要如何寫一個接受閉包的函式呢？</p>
<pre><pre class="playground"><code class="language-rust">fn call_closure&lt;F: Fn(i32) -&gt; i32&gt;(work: F) {
  println!("{}", work(10));
}

fn main() {
  call_closure(|x| x * 2);
}</code></pre></pre>
<p>Rust 中有三個代表函式與閉包有關的 trait 分別是：</p>
<ul>
<li><code>FnOnce</code>:
這個代表它可能會消耗掉它取得的區域變數，所以它可能只能呼叫一次，這對應到上面使用了
<code>move</code> 的閉包</li>
<li><code>FnMut</code>： 這代表它會修改到它的環境，這對應了宣告 <code>mut</code> 的閉包</li>
<li><code>Fn</code>： 這是不會動到環境的閉包，對應到一般的閉包</li>
</ul>
<p>這讓你可以視你的需求選擇使用哪一個，此外，位在列表上面的 trait
也可以接受位在它以下的 trait ，所以 <code>FnOnce</code> 也接受 <code>FnMut</code> 與 <code>Fn</code> ，而
<code>FnMut</code> 接受 <code>Fn</code> ，而三個也都接受一般的函式。</p>
<p>Rust 中也可以讓你傳進一般的函式，所以可以有以下的用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 為 None 時建一個空字串
println!("{:?}", None.unwrap_or_else(String::new));

// 為 None 時用預設值
// 其實這個有 unwrap_or_default 可以用
println!("{}", Option::&lt;i32&gt;::unwrap_or_else(None, Default::default));

// 全部包進 Some 裡面
// Rust 中可以把 tuple struct 當函式用
println!("{:?}", vec![1, 2, 3].into_iter().map(Some).collect::&lt;Vec&lt;_&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>上面那些大概知道就好了，主要是一些讓你可以少建立一個閉包的寫法。</p>
<p>下一篇來介紹智慧指標，與一些集合型態。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../series-1/day-12-單元測試.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../series-1/day-14-智慧指標-smart-pointer-與集合型態-collection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../series-1/day-12-單元測試.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../series-1/day-14-智慧指標-smart-pointer-與集合型態-collection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
